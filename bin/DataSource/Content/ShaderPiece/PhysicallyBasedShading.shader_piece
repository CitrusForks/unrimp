/*********************************************************\
 * Copyright (c) 2012-2017 The Unrimp Team
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 * and associated documentation files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\*********************************************************/


// Overview over different BRDF functions: "Graphic Rants" - "Specular BRDF Reference" - http://graphicrants.blogspot.de/2013/08/specular-brdf-reference.html


//[-------------------------------------------------------]
//[ Pieces                                                ]
//[-------------------------------------------------------]
@piece(DefinePhysicallyBasedShading)
	//[-------------------------------------------------------]
	//[ Constants                                             ]
	//[-------------------------------------------------------]
	#define PI 3.14159265359f


	//[-------------------------------------------------------]
	//[ Ambient                                               ]
	//[-------------------------------------------------------]
	// See http://sunandblackcat.com/tipFullView.php?l=eng&topicid=31&topic=Advanced-GLSL-Lighting-Models
	float3 CalculateHemisphereLighting(float3 worldSpaceNormal, float3 groundColor, float3 skyColor)
	{
		// Cosine between normal and direction to upper hemisphere
		// ->  1 - normal is oriented to upper hemisphere
		// -> -1 - normal is oriented to lower hemisphere
		float3 topHemisphereDirection = float3(0.0f, -1.0f, 0.0f);
		float dotNL = dot(worldSpaceNormal, topHemisphereDirection);

		// From [-1, 1] to [0, 1] range
		float lightInfluence = dotNL * 0.5f + 0.5f;

		// Interpolate colors from upper and lower hemispheres
		return LERP(groundColor, skyColor, lightInfluence);
	}


	//[-------------------------------------------------------]
	//[ Diffuse model                                         ]
	//[-------------------------------------------------------]
	// Burley 2012, "Physically-Based Shading at Disney" - https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf
	float3 diffuseBurley(float3 albedo, float roughness, float dotNV, float dotNL, float dotVH)
	{
		float FD90 = 0.5f + 2.0f * dotVH * dotVH * roughness;
		float FdV = 1.0f + (FD90 - 1.0f) * exp2((-5.55473f * dotNV - 6.98316f) * dotNV);
		float FdL = 1.0f + (FD90 - 1.0f) * exp2((-5.55473f * dotNL - 6.98316f) * dotNL);
		return albedo / PI * FdV * FdL;
	}


	//[-------------------------------------------------------]
	//[ Fresnel                                               ]
	//[-------------------------------------------------------]
	// Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"
	float fresnelSchlick(float ct, float F0)
	{
		return F0 + (1.0f - F0) * pow(1.0f - ct, 5.0f);
	}


	//[-------------------------------------------------------]
	//[ Normal distribution functions (NDF)                   ]
	//[-------------------------------------------------------]
	float NDF_blinnPhong(float dotNH, float alphaSqr)
	{
		return 1.0f / (PI * alphaSqr) * pow(dotNH, 2.0f / alphaSqr - 2.0f);
	}

	float NDF_beckmann(float dotNH, float alphaSqr)
	{
		float dotNH2 = dotNH * dotNH;
		return 1.0f / (PI * alphaSqr * dotNH2 * dotNH2) * exp((dotNH2 - 1.0f) / (alphaSqr * dotNH2));
	}

	// GGX / Trowbridge-Reitz
	// Walter et al. 2007, "Microfacet models for refraction through rough surfaces"
	float NDF_GGX(float dotNH, float alphaSqr)
	{
		return alphaSqr / (PI * pow(dotNH * dotNH * (alphaSqr - 1.0f) + 1.0f, 2.0f));
	}


	//[-------------------------------------------------------]
	//[ Geometry visibility functions (GEOM)                  ]
	//[-------------------------------------------------------]
	float GEOM_SchlickSmith(float dotNL, float dotNV, float alpha)
	{
		float k = pow(0.8f + 0.5f * alpha, 2.0f) / 2.0f;
		float GL = 1.0f / (dotNL * (1.0f - k) + k);
		float GV = 1.0f / (dotNV * (1.0f - k) + k);
		return GL * GV;
	}


	//[-------------------------------------------------------]
	//[ Lighting function                                     ]
	//[-------------------------------------------------------]
	// N = Surface normalize
	// V = Camera direction
	// L = Light direction
	float PBS_Specular(float3 N, float3 V, float3 L, float roughness, float F0)
	{
		float alpha = roughness * roughness;
		float alphaSqr = alpha * alpha;

		float3 H = normalize(V + L);
		float dotNL = SATURATE(dot(N, L));
		float dotNV = SATURATE(dot(N, V));
		float dotNH = SATURATE(dot(N, H));
		float dotLH = SATURATE(dot(L, H));

		// Normal / microfacet distribution
		float Di = NDF_GGX(dotNH, alphaSqr);

		// Fresnel
		float Fs = fresnelSchlick(dotNV, F0);

		// Visibility term
		float Vs = GEOM_SchlickSmith(dotNL, dotNV, alpha);

		// Combine
		return dotNL * Di * Fs * Vs;
	}

	float3 CalculatePbsLighting(float3 albedo, float roughness, float metallic, float3 N, float3 V, float3 L, float3 lightColor)
	{
		// Derive data
		float3 R = reflect(-V, N);
		float3 H = normalize(V + L);
		float dotVH = SATURATE(dot(V, H));
		float dotNV = SATURATE(dot(N, V));
		float dotNL = SATURATE(dot(N, L));

		// Image quality improvement via "Horizon Occlusion for Normal Mapped Reflections" ( http://marmosetco.tumblr.com/post/81245981087 )
		float horizonFade = 1.3f;
		float horiz = SATURATE(1.0f + horizonFade * dot(R, N));
		horiz *= horiz;

		// Diffuse part
		float3 diffuseColor = lightColor * diffuseBurley(albedo, roughness, dotNV, dotNL, dotVH);

		// Reflection part
		// -> Select mip level based on roughness
		R = MultiplyQuaternionVector(PassData.ViewSpaceToWorldSpaceQuaternion, R);
		float2 cubeDimension = GET_TEXTURE_CUBE_SIZE(ReflectionCubeMap);
		float numberOfCubeMipmaps = log2(max(cubeDimension.x, cubeDimension.y));
		float3 reflectionColor = horiz * SAMPLE_CUBE_LOD(ReflectionCubeMap, SamplerLinear, float4(R, roughness * numberOfCubeMipmaps)).rgb;

		// Specular part
		// -> F0 based on metallic factor of material
		float3 F0 = float3(0.04f, 0.04f, 0.04f);
		F0 = LERP(F0, diffuseColor, metallic);
		float3 specularColor = horiz * lightColor * PBS_Specular(N, V, L, roughness, 0.2f);
		reflectionColor -= specularColor;

		// Final output mixes based on material metalness
		return LERP(diffuseColor, reflectionColor, metallic) + specularColor;
	}

	float3 CalculateTraditionalLighting(float3 albedo, float roughness, float metallic, float3 N, float3 V, float3 L, float3 lightColor)
	{
		// Perform traditional Blinn-Phong diffuse and specular lighting

		// Calculate the diffuse lighting
		float diffuseLightFactor = max(dot(N, L), 0.0f);
		float3 diffuseLightColor = lightColor * diffuseLightFactor;

		// Calculate the specular lighting
		float3 viewSpaceHalfVector = normalize(L + V);
		float specularLightFactor = (diffuseLightFactor > 0.0f) ? pow(max(dot(N, viewSpaceHalfVector), 0.0f), 256.0f) : 0.0f;
		float3 specularLightColor = PassData.Wetness * lightColor * specularLightFactor;

		// Diffuse term
		float3 color = diffuseLightColor * albedo;

		// Specular term
		color += specularLightColor * metallic;

		// Done
		return color;
	}

	/**
	*  @brief
	*    Calculate lighting
	*
	*  @param[in] albedo
	*    Albedo = diffuse = base color
	*  @param[in] roughness
	*    Roughness = 1 - glossiness
	*  @param[in] metallic
	*    Metallic
	*  @param[in] N
	*    N = Surface normal
	*  @param[in] V
	*    V = Camera direction
	*  @param[in] L
	*    L = Light direction
	*/
	float3 CalculateLighting(float3 albedo, float roughness, float metallic, float3 N, float3 V, float3 L, float3 lightColor)
	{
		// TODO(co) Traditional lighting is here as preparation for supporting low end hardware as well
		return CalculatePbsLighting(albedo, roughness, metallic, N, V, L, lightColor);
	//	return CalculateTraditionalLighting(albedo, roughness, metallic, N, V, L, lightColor);
	}
@end
